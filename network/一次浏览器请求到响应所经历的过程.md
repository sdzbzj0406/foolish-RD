
##  1. 简单理解
1. DNS域名解析，获取得到对应于域名的IP地址
2. 与目标IP地址建立三次握手连接，若需建立ssl证书握手互信
3. 发起http协议请求，获取得到请求内容
4. 浏览器得到请求内容后，实现html页面渲染

##  2. 深度解析
### 2.1 DNS解析
浏览器首先提取URL中的主机名，然后通过本地DNS缓存来查找对应的IP地址。如果缓存不存在，浏览器向本地域名服务器发送DNS解析请求。DNS存在多级缓存，缓存顺序是：浏览器缓存--> 系统缓存-->路由器缓存-->IPS服务器缓存-->根域名缓存-->顶级域名缓存-->主域名缓存。
### 2.2建立TPC连接
![[TCP三次握手.png]]
第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN。此时客户端处于SYN_SENT的状态。
第二次握手：服务端收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN(S)。同时会把客户端的ISN+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RCVD的状态。
第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经接收到了服务端的SYN报文，此时客户端于ESTABLISHED状态。
服务器收到ACK报文之后，也处于ESTABLISHED状态，此时，双方建立起了连接。

#### 为什么是三次而不是两次？
假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。
由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样拜拜浪费了。
采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。

### 2.3 发送HTTP请求
构建HTTP请求报文，并通过TCP协议发送到服务器的指定端口。请求报文由请求行，请求报头，请求正文组成。请求行包含请求方法（如GET、POST）、路径和HTTP协议的版本，格式为Method， Request-URL， HTTP-Version， CRLF。请求头包含附加的元数据，例如用户代理、接受的内容类型等。请求体包含可选的请求数据，例如在POST请求中发送的表单数据。

### 2.4 服务器处理请求
服务器接收到HTTP请求后，会解析请求行和请求头，确定要执行的操作。服务器可能会执行一系列操作，包括读取数据库、处理业务逻辑等。一旦服务器准备好响应，它将生成一个HTTP响应。

### 2.5 发送HTTP响应
服务器通过TCP连接将HTTP响应发送回浏览器。HTTP响应由响应行、响应头和响应体组成。响应行包含HTTP协议的版本、状态码和状态消息。响应头包含服务器的信息、响应的元数据等。响应体包含实际的响应数据，例如HTML文档、图像或其他媒体类型。

### 2.6 浏览器处理响应 
浏览器接收到HTTP响应后，会首先检查状态码。常见的状态码包括200（成功）、404（未找到）和500（服务器错误）等。根据响应的内容类型，浏览器会采取相应的处理方式。例如，如果响应是HTML文档，浏览器会解析文档并构建DOM树，然后开始渲染页面。

### 2.7 页面渲染
浏览器根据收到的响应数据和解析的DOM树开始加载页面。它会解析HTML标记，并根据CSS样式表对元素进行布局和样式设置。同时，浏览器会执行JavaScript代码来处理页面的交互和动态效果。

### 2.8 关闭TCP连接
一旦页面加载完成，浏览器会关闭与服务器之间的TCP连接。这是通过四次握手完成的，确保双方都能正常终止连接。
![[TCP四次挥手.png]]

#### 为何不采用“三次握手”释放连接？

服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序：

如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；
如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，
从上面过程可知，是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送。

#### 发送最后一次握手报文后要等待2MSL(最长报文段寿命)的时间呢？

为了防止上次连接的报文数据影响到下次的连接，有充分的的时间处理上次连接的报文信息。尽量保证接收到所有的数据。断开连接的时候，可能存在未被接收的数据滞留在网络中，可能有些才刚刚被发出，2MSL正好保证了 从服务端发送 到 服务端收到应答的时间，即一来一回。
因为客户端需确认服务端收到了自己的确认报文，避免服务端没有收到客户端的确认报文一直等待客户端的确认从而消耗资源，于是客户端等待2MSL，如果在这个时间段内再次收到服务端的释放报文表示之前的发送的确认报文服务端没有接收成功，于是再次发送确认报文，且将time_wait计时器重置。
