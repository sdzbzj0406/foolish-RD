## 常见方法包含：计数器算法，固定窗口算法，滑动窗口算法，令牌桶算法，漏桶算法。算法都有各自的优缺点，选择合适的算法取决于具体的需求和应用场景

## 计数器算法

统计一段时间内允许通过的请求数，每来一个请求，计数器减一，若计数器为0，则请求被拒绝。缺点是无法平滑处理请求，导致很多后来的请求只能被过滤掉。

## 固定窗口算法

固定窗口算法是最简单的限流算法之一。它将请求均匀地分布在固定大小的时间窗口内。例如，如果一个窗口的大小是1秒，限制是每秒最多处理10个请求，那么在每个1秒的窗口内，只有前10个请求会被处理，超出的请求将被拒绝。缺点是无法平滑的处理请求。

## 滑动窗口算法

滑动窗口算法是对固定窗口算法的改进。它将时间窗口划分为更小的时间段，通常是1秒的倍数。在每个时间段内，都有一个计数器记录该时间段内的请求数量。通过滑动窗口的方式，可以平滑地控制请求流量，而不仅限制在固定窗口内的数量。

## 令牌桶算法

令牌桶算法使用一个令牌桶来控制请求的速率。令牌桶中以固定速率生成令牌，并将令牌存储在桶中。每当有一个请求到达时，它必须获取一个令牌才能被处理。如果令牌桶中没有足够的令牌，请求将被拒绝。令牌桶算法可以在一定程度上应对突发请求，因为如果令牌未被使用，它们将会累积在令牌桶中。可通过redis的lua脚本来保证操作的原子性。

## 漏桶算法（Leaky Bucket Algorithm）

漏桶算法与令牌桶算法类似，但是漏桶算法以固定的速率处理请求，而不管请求的突发性。漏桶算法将请求看作是水滴，以恒定的速率从桶中漏出。如果请求到达时桶已满，则请求将被拒绝。漏桶算法可以平滑地控制请求的处理速率，防止突发流量对系统的影响。

## 比较漏桶算法和令牌桶算法

两者均可以实现限制数据的平均传输速率，但令牌桶可支持某种程度的突发传输。因为漏桶的传输速率是固定的，当一下子来了大量请求，请求速率不会发生变化；但令牌桶可保证只要可以拿到令牌，就可以马上进行处理。实际生产中，**一般会将漏桶算法和令牌桶算法结合起来使用**。